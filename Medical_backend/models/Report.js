const mongoose = require('mongoose');

/**
 * Report Model
 * Represents system reports and analytics
 * Part of: Data Analysis & Reporting use case
 */
const reportSchema = new mongoose.Schema({
  // Report Information
  reportType: {
    type: String,
    required: true,
    enum: [
      'Appointment Summary',
      'Revenue Report',
      'Patient Demographics',
      'Doctor Performance',
      'Department Statistics',
      'Payment Analytics',
      'System Usage',
      'Custom Report'
    ]
  },
  
  title: {
    type: String,
    required: true
  },
  
  description: String,
  
  // Report Parameters
  parameters: {
    startDate: Date,
    endDate: Date,
    department: String,
    doctorId: mongoose.Schema.Types.ObjectId,
    patientId: mongoose.Schema.Types.ObjectId,
    customFilters: mongoose.Schema.Types.Mixed
  },
  
  // Report Data
  data: mongoose.Schema.Types.Mixed,
  
  // Summary Statistics
  summary: {
    totalRecords: Number,
    keyMetrics: mongoose.Schema.Types.Mixed
  },
  
  // Generated By
  generatedBy: {
    userId: String,
    userName: String,
    userType: String
  },
  
  // Status
  status: {
    type: String,
    enum: ['Generating', 'Completed', 'Failed'],
    default: 'Generating'
  },
  
  // Export Information
  format: {
    type: String,
    enum: ['JSON', 'PDF', 'Excel', 'CSV'],
    default: 'JSON'
  },
  
  fileUrl: String,
  fileSize: Number,
  
  // Timestamps
  generatedAt: {
    type: Date,
    default: Date.now
  },
  expiresAt: Date,
  
  // Access Control
  isPublic: {
    type: Boolean,
    default: false
  },
  
  accessedBy: [{
    userId: String,
    accessedAt: Date
  }]
}, {
  timestamps: true
});

// Indexes
reportSchema.index({ reportType: 1, generatedAt: -1 });
reportSchema.index({ 'generatedBy.userId': 1, generatedAt: -1 });
reportSchema.index({ status: 1 });
reportSchema.index({ expiresAt: 1 });

// Set expiration (30 days by default)
reportSchema.pre('save', function(next) {
  if (!this.expiresAt) {
    this.expiresAt = new Date(Date.now() + 30 * 24 * 60 * 60 * 1000); // 30 days
  }
  next();
});

// Static method to generate appointment summary
reportSchema.statics.generateAppointmentSummary = async function(startDate, endDate, generatedBy) {
  const Appointment = mongoose.model('Appointment');
  
  const appointments = await Appointment.find({
    appointmentDate: { $gte: startDate, $lte: endDate }
  }).populate('doctor patient');
  
  const summary = {
    total: appointments.length,
    byStatus: {},
    bySpecialty: {},
    byType: {}
  };
  
  appointments.forEach(apt => {
    // Count by status
    summary.byStatus[apt.status] = (summary.byStatus[apt.status] || 0) + 1;
    
    // Count by specialty
    if (apt.doctor && apt.doctor.specialty) {
      summary.bySpecialty[apt.doctor.specialty] = (summary.bySpecialty[apt.doctor.specialty] || 0) + 1;
    }
    
    // Count by type
    summary.byType[apt.appointmentType] = (summary.byType[apt.appointmentType] || 0) + 1;
  });
  
  const report = new this({
    reportType: 'Appointment Summary',
    title: `Appointment Summary: ${startDate.toDateString()} - ${endDate.toDateString()}`,
    parameters: { startDate, endDate },
    data: appointments,
    summary: {
      totalRecords: appointments.length,
      keyMetrics: summary
    },
    generatedBy,
    status: 'Completed'
  });
  
  await report.save();
  return report;
};

// Static method to generate revenue report
reportSchema.statics.generateRevenueReport = async function(startDate, endDate, generatedBy) {
  const Payment = mongoose.model('Payment');
  
  const payments = await Payment.find({
    paymentDate: { $gte: startDate, $lte: endDate },
    status: 'Completed'
  }).populate('patient appointment');
  
  const summary = {
    totalRevenue: 0,
    totalRefunds: 0,
    netRevenue: 0,
    byPaymentMethod: {},
    transactionCount: payments.length
  };
  
  payments.forEach(payment => {
    summary.totalRevenue += payment.amount;
    summary.totalRefunds += payment.refundAmount;
    summary.byPaymentMethod[payment.paymentMethod] = 
      (summary.byPaymentMethod[payment.paymentMethod] || 0) + payment.amount;
  });
  
  summary.netRevenue = summary.totalRevenue - summary.totalRefunds;
  
  const report = new this({
    reportType: 'Revenue Report',
    title: `Revenue Report: ${startDate.toDateString()} - ${endDate.toDateString()}`,
    parameters: { startDate, endDate },
    data: payments,
    summary: {
      totalRecords: payments.length,
      keyMetrics: summary
    },
    generatedBy,
    status: 'Completed'
  });
  
  await report.save();
  return report;
};

module.exports = mongoose.model('Report', reportSchema);
